<!doctype html>
<html lang=ru>
<head>
    <meta charset=utf-8>
    <meta content="width=device-width,initial-scale=1" name=viewport>
    <meta content="Вебхуки" name=description>
    <meta content="#FFFFFF" name=theme-color>
    <meta content="Пишем ботов для Telegram на языке Python" property="og:title">
    <meta content="article" property="og:type">
    <meta content="Урок 4: Вебхуки" property="og:description">
    <meta content="https://mastergroosha.github.io/telegram-tutorial/docs/lesson_04/" property="og:url">
    <meta content="Пишем ботов для Telegram на языке Python" property="og:site_name">
    <meta content="https://mastergroosha.github.io/telegram-tutorial/bot_logo.png" property="og:image">
    <title>Урок 4: Вебхуки | Пишем ботов для Telegram на языке Python</title>
    <link href=/telegram-tutorial/manifest.json rel=manifest>
    <link href=/telegram-tutorial/favicon.png rel=icon type=image/x-icon>
    <link href=/telegram-tutorial/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css
          integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA+eA0kDHPqIYF+1eU="
          rel=stylesheet>
</head>
<body><input class=hidden id=menu-control type=checkbox>
<main class="container flex">
    <aside class=book-menu>
        <nav><h2 class=book-brand><a href=/telegram-tutorial><span>Пишем ботов для Telegram на языке Python</span></a>
        </h2>
            <ul>
                <li class=book-section-flat><span>pyTelegramBotAPI</span>
                    <ul>
                        <li><a href=/telegram-tutorial/docs/pyTelegramBotAPI/lesson_00/>Урок 0. Подготовка рабочего
                            места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. «Угадай мелодию». Подготовка</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. «Угадай мелодию». Завершаем бота</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_04/ class=active>Урок 4. Вебхуки</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan
                            (неактуально)</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование
                            сообщений</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять
                            редактирование сообщений, кэшированный инлайн</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в
                            группах</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги.
                            Конечные автоматы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном
                            сервере</a></li>
                    </ul>
                </li>
                <li class=book-section-flat><span>aiogram</span>
                    <ul>
                        <li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем
                            логику по файлам</a></li>
                    </ul>
                </li>
            </ul>
            <ul>
                <li><a href=/telegram-tutorial/posts/></a></li>
            </ul>
        </nav>
        <script>(function () {
            var menu = document.querySelector("aside.book-menu nav");
            addEventListener("beforeunload", function (event) {
                localStorage.setItem("menu.scrollTop", menu.scrollTop);
            });
            menu.scrollTop = localStorage.getItem("menu.scrollTop");
        })();</script>
    </aside>
    <div class=book-page>
        <header class=book-header>
            <div class="flex align-center justify-between"><label for=menu-control><img
                    alt=Menu class=book-icon src=/telegram-tutorial/svg/menu.svg></label>
                <strong>Урок 4</strong>
                <label for=toc-control><img alt="Table of Contents" class=book-icon src=/telegram-tutorial/svg/toc.svg></label>
            </div>
            <input class=hidden id=toc-control type=checkbox>
            <aside class="hidden clearfix">
                <nav id=TableOfContents>
                    <ul>
                        <li>
                            <ul>
                                <li><a href=#а-в-чём-собственно-разница>А в чём, собственно, разница?</a></li>
                                <li><a href=#создаем-сертификат>Создаем сертификат</a></li>
                                <li><a href=#наш-вишнёвый-сервер>Наш вишнёвый сервер</a></li>
                                <li><a href=#новый-старый-бот>Новый старый бот</a></li>
                            </ul>
                        </li>
                    </ul>
                </nav>
            </aside>
        </header>
        <article class=markdown><h1>Вебхуки</h1>
            <p>
            <p>С простым ботом наконец-то разобрались, теперь будем осваивать различные &ldquo;плюшки&rdquo;. Первая из
                них и, пожалуй, самая главная, — вебхуки.</p>
            <h2 id=а-в-чём-собственно-разница>А в чём, собственно, разница?</h2>
            <p><em>(Следующий абзац был написан в 2015-2016г., библиотеки с того момента много обновлялись, поэтому в
                некоторых случаях использовать Long Polling будет не хуже, чем вебхуки)</em>.<br>Давайте для начала
                разберемся, как боты принимают сообщения. Первый и наиболее простой вариант заключается в периодическом
                опросе серверов Telegram на предмет наличия новой информации. Всё это осуществляется через т.н. <a
                        href=https://en.wikipedia.org/wiki/Push_technology#Long_polling>Long Polling</a>, т.е.
                открывается соединение на непродолжительное время и все обновления тут же прилетают боту. Просто, но не
                очень надежно. Во-первых, серверы Telegram периодически начинают возвращать <a
                        href=https://ru.wikipedia.org/wiki/%d0%a1%d0%bf%d0%b8%d1%81%d0%be%d0%ba_%d0%ba%d0%be%d0%b4%d0%be%d0%b2_%d1%81%d0%be%d1%81%d1%82%d0%be%d1%8f%d0%bd%d0%b8%d1%8f_HTTP#504>ошибку
                    504</a> (Gateway Timeout), из-за чего некоторые боты впадают в ступор. Даже pyTelegramBotAPI,
                используемый мной, не всегда может пережить такое.
                Во-вторых, если одновременно запущено несколько ботов, вероятность столкнуться с ошибками возрастает.
                Это вдвойне обидно, если сами боты используются не очень часто.</p>
            <p>Вебхуки работают несколько иначе. Устанавливая вебхук, вы как бы говорите серверам Telegram: &ldquo;Слышь,
                если кто мне напишет, стукни сюда — (ссылка)&rdquo;. Отпадает необходимость периодически самому
                опрашивать серверы, тем самым, исчезает неприятная причина падений ботов. Однако за это приходится
                платить необходимостью установки полноценного веб-сервера на ту машину, на которой планируется запускать
                ботов. Что ещё неприятно, надо иметь собственный SSL-сертификат, т.к. вебхуки в телеграме работают
                только по <a href=https://ru.wikipedia.org/wiki/HTTPS>HTTPS</a>. К счастью, в один прекрасный день
                появилась поддержка <a
                        href=https://ru.wikipedia.org/wiki/%d0%a1%d0%b0%d0%bc%d0%be%d0%b7%d0%b0%d0%b2%d0%b5%d1%80%d0%b5%d0%bd%d0%bd%d1%8b%d0%b9_%d1%81%d0%b5%d1%80%d1%82%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82>самоподписанных
                    сертификатов</a>. Вот об их применении я и расскажу.</p>
            <h2 id=создаем-сертификат>Создаем сертификат</h2>
            <p>Повторюсь: я не считаю себя супер-мега-крутым специалистом в айти, возможно, я что-то делаю неправильно,
                тем не менее, это работает и выглядит вполне прилично. Ладно, приступим.<br>Для начала, установим пакет
                openssl (для Linux):<br><code>sudo apt-get install openssl</code><br>Затем сгенерируем приватный
                ключ:<br><code>openssl genrsa -out webhook_pkey.pem 2048</code><br>Теперь, внимание, генерируем
                самоподписанный сертификат вот этой вот длинной командой:<br><code>openssl req -new -x509 -days 3650
                    -key webhook_pkey.pem -out webhook_cert.pem</code><br>Нам предложат ввести некоторую информацию о
                себе: двухбуквенный код страны, имя организации и т.д. Если не хотите ничего вводить, ставьте точку.
                <strong>НО! ВАЖНО!</strong> Когда дойдете до предложения ввести Common Name, следует написать IP адрес
                сервера, на котором будет запущен бот.</p>
            <center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l4_1.jpg></center>
            <center><i>Генерация сертификата</i></center>
            <p>В результате получим файлы <code>webhook_cert.pem</code> и <code>webhook_pkey.pem</code>, положим их в
                какой-нибудь пустой каталог, в котором потом будем создавать бота. Сертификаты готовы, теперь займемся
                ботом. Чтобы не сильно загружать себе мозги, напишем простого echo-bot&rsquo;а из <a
                        href=/telegram-tutorial/docs/lesson_01/>урока №1</a>, только теперь с использованием
                сертификата.</p>
            <h2 id=наш-вишнёвый-сервер>Наш вишнёвый сервер</h2>
            <p>Выше я упомянул необходимость наличия веб-сервера, для работы с вебхуками. Те, кто умело владеет Apache
                или Nginx, можете дальше не читать. Лично я никак не мог (и не могу до сих пор) понять, как обрабатывать
                входящие сообщения от этих серверов в Python. Поэтому, было принято простое и довольно эффективное
                решение - используем веб-фреймворк <a href=http://www.cherrypy.org/>CherryPy</a>. Это не самый простой
                фреймворк по сравнению, например, с <a href=http://flask.pocoo.org/>Flask</a>, но мы будем использовать
                именно его.<br>Итак, установим CherryPy простой командой <code>python3 -m pip install cherrypy</code>
            </p>
            <h2 id=новый-старый-бот>Новый старый бот</h2>
            <p>Перейдем в каталог с нашими сертификатами и создадим файлы <code>bot.py</code> и <code>config.py</code>.
                В последнем создадим переменную <code>token</code>, в которую передадим токен нашего бота. Открываем
                <code>bot.py</code>.<br>Импортируем 2 библиотеки, зададим необходимые константы и создадим экземпляр
                бота:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:green>#!/usr/bin/env/python3</span>
<span style=color:green># -*- coding: utf-8 -*-</span>
<span style=color:#00f>import</span> telebot
<span style=color:#00f>import</span> cherrypy
<span style=color:#00f>import</span> config

WEBHOOK_HOST = <span style=color:#a31515>&#39;IP-адрес сервера, на котором запущен бот&#39;</span>
WEBHOOK_PORT = 443  <span style=color:green># 443, 80, 88 или 8443 (порт должен быть открыт!)</span>
WEBHOOK_LISTEN = <span style=color:#a31515>&#39;0.0.0.0&#39;</span>  <span style=color:green># На некоторых серверах придется указывать такой же IP, что и выше</span>

WEBHOOK_SSL_CERT = <span style=color:#a31515>&#39;./webhook_cert.pem&#39;</span>  <span style=color:green># Путь к сертификату</span>
WEBHOOK_SSL_PRIV = <span style=color:#a31515>&#39;./webhook_pkey.pem&#39;</span>  <span style=color:green># Путь к приватному ключу</span>

WEBHOOK_URL_BASE = <span style=color:#a31515>&#34;https://</span><span style=color:#a31515>%s</span><span
                        style=color:#a31515>:</span><span style=color:#a31515>%s</span><span
                        style=color:#a31515>&#34;</span> % (WEBHOOK_HOST, WEBHOOK_PORT)
WEBHOOK_URL_PATH = <span style=color:#a31515>&#34;/</span><span style=color:#a31515>%s</span><span style=color:#a31515>/&#34;</span> % (config.token)

bot = telebot.TeleBot(config.token)
</code></pre>
            </div>
            <p><strong>Обратите внимание</strong>, что Telegram поддерживает всего 4 различных порта при работе с
                самоподписанными сертификатами. Теоретически, это означает, что на одной машине может быть запущено не
                больше 4 ботов на вебхуках. Практически, это поправимо, но об этом - в следующий раз.</p>
            <p>Создадим класс, реализующий экземпляр веб-сервера. Это, в принципе, стандартный код, который от бота к
                боту сильно меняться не будет:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:green># Наш вебхук-сервер</span>
<span style=color:#00f>class</span> <span style=color:#2b91af>WebhookServer</span>(object):
    @cherrypy.expose
    <span style=color:#00f>def</span> index(self):
        <span style=color:#00f>if</span> <span style=color:#a31515>&#39;content-length&#39;</span> <span
                        style=color:#00f>in</span> cherrypy.request.headers <span style=color:#00f>and</span> \
                        <span style=color:#a31515>&#39;content-type&#39;</span> <span style=color:#00f>in</span> cherrypy.request.headers <span
                        style=color:#00f>and</span> \
                        cherrypy.request.headers[<span style=color:#a31515>&#39;content-type&#39;</span>] == <span
                        style=color:#a31515>&#39;application/json&#39;</span>:
            length = int(cherrypy.request.headers[<span style=color:#a31515>&#39;content-length&#39;</span>])
            json_string = cherrypy.request.body.read(length).decode(<span style=color:#a31515>&#34;utf-8&#34;</span>)
            update = telebot.types.Update.de_json(json_string)
            <span style=color:green># Эта функция обеспечивает проверку входящего сообщения</span>
            bot.process_new_updates([update])
            <span style=color:#00f>return</span> <span style=color:#a31515>&#39;&#39;</span>
        <span style=color:#00f>else</span>:
            <span style=color:#00f>raise</span> cherrypy.HTTPError(403)
</code></pre>
            </div>
            <p>Посмотрите на название функции: <code>index</code>. Это, по сути, обозначает последнюю часть URL. Поясню
                на примере: если бы мы хотели получать обновления на адрес <code>80.100.95.20/webhooksbot</code>, то
                функцию выше мы бы назвали <code>webhooksbot</code>. index - это аналог отсутствия какой-либо
                дополнительной маршрутизации. Зачем менять это значение на другое, рассказано <a
                        href=/telegram-tutorial/docs/lesson_12/>здесь 12</a>, сейчас это не нужно.<br>Итак, что мы видим
                в коде выше? Принимаем входящие запросы по URL <code>наш.ip.адрес/</code>, получаем содержимое и
                прогоняем через набор хэндлеров. Кстати, о них. Т.к. мы реализуем простейших echo-бот, хэндлер нам нужен
                всего один:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span
                    style=color:green># Хэндлер на все текстовые сообщения</span>
@bot.message_handler(func=<span style=color:#00f>lambda</span> message: True, content_types=[<span style=color:#a31515>&#39;text&#39;</span>])
<span style=color:#00f>def</span> echo_message(message):
    bot.reply_to(message, message.text)
</code></pre>
            </div>
            <p>Внимательный читатель всё же заметит одно отличие, о котором я говорить не буду ;) Заодно ещё один повод
                открыть документацию.</p>
            <p>Далее, отправим серверу наш самоподписанный сертификат и &ldquo;обратный адрес&rdquo;, по которому просим
                сообщать обо всех новых сообщениях:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:green># Снимаем вебхук перед повторной установкой (избавляет от некоторых проблем)</span>
bot.remove_webhook()

<span style=color:green># Ставим заново вебхук</span>
bot.set_webhook(url=WEBHOOK_URL_BASE + WEBHOOK_URL_PATH,
                certificate=open(WEBHOOK_SSL_CERT, <span style=color:#a31515>&#39;r&#39;</span>))
</code></pre>
            </div>
            <p>Наконец, укажем настройки нашего сервера и запустим его!</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:green># Указываем настройки сервера CherryPy</span>
cherrypy.config.update({
    <span style=color:#a31515>&#39;server.socket_host&#39;</span>: WEBHOOK_LISTEN,
    <span style=color:#a31515>&#39;server.socket_port&#39;</span>: WEBHOOK_PORT,
    <span style=color:#a31515>&#39;server.ssl_module&#39;</span>: <span style=color:#a31515>&#39;builtin&#39;</span>,
    <span style=color:#a31515>&#39;server.ssl_certificate&#39;</span>: WEBHOOK_SSL_CERT,
    <span style=color:#a31515>&#39;server.ssl_private_key&#39;</span>: WEBHOOK_SSL_PRIV
})

 <span style=color:green># Собственно, запуск!</span>
cherrypy.quickstart(WebhookServer(), WEBHOOK_URL_PATH, {<span style=color:#a31515>&#39;/&#39;</span>: {}})
</code></pre>
            </div>
            <p>Обратите внимание на последнюю строку. Наш сервер в качестве &ldquo;корня&rdquo; будет прослушивать адрес
                вида &ldquo;ip-адрес/токен_бота&rdquo;, относительно которого index - это и есть этот адрес. Может,
                немного криво пояснил, но позднее вам всё станет предельно ясно, сейчас не нужно загромождать голову
                лишней информацией.</p>
            <p>Запустим бота и напишем ему парочку сообщений. Затем посмотрим в окно терминала:</p>
            <center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l4_2.jpg></center>
            <center><i>Лог сервера</i></center>
            <p>Если код статуса равен <a
                    href=https://ru.wikipedia.org/wiki/%d0%a1%d0%bf%d0%b8%d1%81%d0%be%d0%ba_%d0%ba%d0%be%d0%b4%d0%be%d0%b2_%d1%81%d0%be%d1%81%d1%82%d0%be%d1%8f%d0%bd%d0%b8%d1%8f_HTTP#200>200
                (OK)</a>, значит, всё в порядке и бот получил сообщения от сервера.</p>
            <p>На сегодня всё.</p>
            <p><a href=/telegram-tutorial/docs/lesson_03/ class=book-btn style=float:left>← Урок №3</a>
                <a href=/telegram-tutorial/docs/lesson_05/ class=book-btn style=float:right>Урок №5 →</a></p></p>
        </article>
        <footer class=book-footer>
            <div class="flex flex-wrap justify-between"></div>
        </footer>
        <label class="hidden book-menu-overlay" for=menu-control></label></div>
    <aside class=book-toc>
        <nav id=TableOfContents>
            <ul>
                <li>
                    <ul>
                        <li><a href=#а-в-чём-собственно-разница>А в чём, собственно, разница?</a></li>
                        <li><a href=#создаем-сертификат>Создаем сертификат</a></li>
                        <li><a href=#наш-вишнёвый-сервер>Наш вишнёвый сервер</a></li>
                        <li><a href=#новый-старый-бот>Новый старый бот</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </aside>
</main>
</body>
</html>