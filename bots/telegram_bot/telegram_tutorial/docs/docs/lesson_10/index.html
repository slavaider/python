<!doctype html>
<html lang=ru>
<head>
    <meta charset=utf-8>
    <meta content="width=device-width,initial-scale=1" name=viewport>
    <meta content="Bot API v3. Автоматизируем работу в группах" name=description>
    <meta content="#FFFFFF" name=theme-color>
    <meta content="Пишем ботов для Telegram на языке Python" property="og:title">
    <meta content="article" property="og:type">
    <meta content="Урок 10: Bot API v3. Автоматизируем работу в группах" property="og:description">
    <meta content="https://mastergroosha.github.io/telegram-tutorial/docs/lesson_10/" property="og:url">
    <meta content="Пишем ботов для Telegram на языке Python" property="og:site_name">
    <meta content="https://mastergroosha.github.io/telegram-tutorial/bot_logo.png" property="og:image">
    <title>Урок 10: Bot API v3. Автоматизируем работу в группах | Пишем ботов для Telegram на языке Python</title>
    <link href=/telegram-tutorial/manifest.json rel=manifest>
    <link href=/telegram-tutorial/favicon.png rel=icon type=image/x-icon>
    <link href=/telegram-tutorial/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css
          integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA+eA0kDHPqIYF+1eU="
          rel=stylesheet>
</head>
<body><input class=hidden id=menu-control type=checkbox>
<main class="container flex">
    <aside class=book-menu>
        <nav><h2 class=book-brand><a href=/telegram-tutorial><span>Пишем ботов для Telegram на языке Python</span></a>
        </h2>
            <ul>
                <li class=book-section-flat><span>pyTelegramBotAPI</span>
                    <ul>
                        <li><a href=/telegram-tutorial/docs/pyTelegramBotAPI/lesson_00/>Урок 0. Подготовка рабочего
                            места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. «Угадай мелодию». Подготовка</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. «Угадай мелодию». Завершаем бота</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan
                            (неактуально)</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование
                            сообщений</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять
                            редактирование сообщений, кэшированный инлайн</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_10/ class=active>Урок 10. Bot API v3. Автоматизируем
                            работу в группах</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги.
                            Конечные автоматы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном
                            сервере</a></li>
                    </ul>
                </li>
                <li class=book-section-flat><span>aiogram</span>
                    <ul>
                        <li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем
                            логику по файлам</a></li>
                    </ul>
                </li>
            </ul>
            <ul>
                <li><a href=/telegram-tutorial/posts/></a></li>
            </ul>
        </nav>
        <script>(function () {
            var menu = document.querySelector("aside.book-menu nav");
            addEventListener("beforeunload", function (event) {
                localStorage.setItem("menu.scrollTop", menu.scrollTop);
            });
            menu.scrollTop = localStorage.getItem("menu.scrollTop");
        })();</script>
    </aside>
    <div class=book-page>
        <header class=book-header>
            <div class="flex align-center justify-between"><label for=menu-control><img
                    alt=Menu class=book-icon src=/telegram-tutorial/svg/menu.svg></label>
                <strong>Урок 10</strong>
                <label for=toc-control><img alt="Table of Contents" class=book-icon src=/telegram-tutorial/svg/toc.svg></label>
            </div>
            <input class=hidden id=toc-control type=checkbox>
            <aside class="hidden clearfix">
                <nav id=TableOfContents>
                    <ul>
                        <li>
                            <ul>
                                <li><a href=#удаляем-сообщения>Удаляем сообщения</a></li>
                                <li><a href=#read-only-и-прочие-мягкие-наказания>Read-Only и прочие «мягкие»
                                    наказания</a></li>
                                <li><a href=#заключение>Заключение</a></li>
                            </ul>
                        </li>
                    </ul>
                </nav>
            </aside>
        </header>
        <article class=markdown><h1>Bot API v3. Автоматизируем работу в группах</h1>
            <p>
            <p>⁠⁠
                С момента публикации <a href=/telegram-tutorial/docs/lesson_09/>предыдущего урока</a> и по состоянию на
                момент написания этого, Telegram выпустил <a
                        href=https://core.telegram.org/bots/api-changelog#may-18-2017>одно крупное обновление</a> Bot
                API (3.0), а также несколько мелких (3.1-3.3). Сразу отмечу, ни отправка видеосообщений, ни платежи (по
                ним есть отличный <a
                        href=https://github.com/eternnoir/pyTelegramBotAPI/blob/master/examples/payments_example.py>пример</a>
                в репозитории pyTelegramBotAPI), ни работа со стикерами рассмотрены не будут.</p>
            <h2 id=удаляем-сообщения>Удаляем сообщения</h2>
            <p>Начнём с того, что научим нашего бота в группе удалять сообщения, в которых есть ссылки. Добавим бота в
                группу и назначим его администратором с правом удаления и блокировки (пригодится позже).</p>
            <center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l10_1.png></center>
            <center><i>Выдача прав боту</i></center>
            <p>Дабы избежать неприятных ситуаций, нам необходимо определить две вещи: в какой именно группе он будет
                удалять сообщения и как отличить сообщения с ссылками от всех остальных? Для начала узнаем и запишем
                куда-нибудь ID нашей группы. А что делать с ссылками? Неужели нам придётся использовать <a
                        href=https://ru.wikipedia.org/wiki/%d0%a0%d0%b5%d0%b3%d1%83%d0%bb%d1%8f%d1%80%d0%bd%d1%8b%d0%b5_%d0%b2%d1%8b%d1%80%d0%b0%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f>регулярные
                    выражения</a>, создавая себе <a href=https://imgs.xkcd.com/comics/perl_problems.png>ещё одну
                    проблему</a>? Конечно, нет! Все «особые» элементы, будь то ссылки, @юзернеймы, команды ботов и т.д.
                складываются в массив <code>entities</code> в объекте <code>Message</code>, нам остаётся лишь проверить
                тип объекта и решить, удалять конкретное сообщение или нет. За последнее отвечает метод <code>delete_message</code>,
                принимающий на вход два аргумента: ID чата и ID сообщения.</p>
            <p>Перейдём непосредственно к коду. Дабы упростить себе жизнь, зададим нужные условия срабатывания (нужный
                ID чата и непустой массив entities) сразу в хэндлер, это сэкономит нам несколько лишних проверок.</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python>GROUP_ID = -10012345  <span
                    style=color:green># Ваш ID группы</span>

@bot.message_handler(func=<span style=color:#00f>lambda</span> message: message.entities <span
                        style=color:#00f>is</span> <span style=color:#00f>not</span> None <span
                        style=color:#00f>and</span> message.chat.id == GROUP_ID)
<span style=color:#00f>def</span> delete_links(message):
    <span style=color:#00f>for</span> entity <span style=color:#00f>in</span> message.entities:  <span
                        style=color:green># Пройдёмся по всем entities в поисках ссылок</span>
        <span style=color:green># url - обычная ссылка, text_link - ссылка, скрытая под текстом</span>
        <span style=color:#00f>if</span> entity.type <span style=color:#00f>in</span> [<span style=color:#a31515>&#34;url&#34;</span>, <span
                        style=color:#a31515>&#34;text_link&#34;</span>]:
            <span style=color:green># Мы можем не проверять chat.id, он проверяется ещё в хэндлере </span>
            bot.delete_message(message.chat.id, message.message_id)
        <span style=color:#00f>else</span>:
            <span style=color:#00f>return</span>
</code></pre>
            </div>
            <p>Запустим бота и попробуем отправить сообщение с ссылкой. Если вы всё сделали правильно, оно мгновенно
                исчезнет и в разделе «Недавние действия» (Recent Actions) появится запись об удалённом сообщении.</p>
            <center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l10_2.png></center>
            <center><i>Сообщение удалено</i></center>
            <p>Точно так же можно сделать удаление чего угодно: стикеров, репостов из неугодных каналов, матерных
                сообщений и т.д. Возможности (почти) безграничны!</p>
            <h2 id=read-only-и-прочие-мягкие-наказания>Read-Only и прочие «мягкие» наказания</h2>
            <p>Представьте, что у вас есть группа, например, &ldquo;Международный клуб любителей мяса&rdquo;, в котором
                люди на разных языках делятся своими впечатлениями от поедания свинины, говядины, баранины и т.д.<br>Конечно,
                время от времени в чатик будут приходить вегетарианцы и высказывать недовольство, но так как мы
                терпеливые люди, не будем банить веганов, а просто запретим им писать сообщения некоторое время, дабы
                они успокоились и вели дискуссию в рамках тематики чата. Усложним себе задачу и будем оповещать
                пользователей о временном ограничении прав, исходя из их языковой принадлежности.</p>
            <p>Начиная с <a href=https://medium.com/@tglive/telegram-4-1-bbff31db5132>Telegram 4.1</a>, у
                администраторов групп появилась возможность точечно настраивать права и ограничения пользователей. В Bot
                API за операцию ограничения ответственен метод <code>restrict_chat_member</code>, принимающий на вход ID
                чата, ID юзера, список ограничений, а также параметр <code>until_date</code> со значением времени (Unix
                Time), до которого эти ограничения действуют, причём если указать время с разницей меньше 30 секунд или
                больше 366 дней от текущего, Telegram воспринимает это, как «навсегда». В нашем случае Read-Only режим
                будет выдаваться на 10 минут, т.е. 600 секунд.</p>
            <p>Давайте теперь разберёмся, на каком языке отвечать пользователю. В объекте <a
                    href=https://core.telegram.org/bots/api#user>User</a> есть поле <code>language_code</code>,
                содержащее языковую метку пользователя. Не всё так просто, ведь в зависимости от настроек системы и
                местоположения пользователя, его языковая метка может быть <code>ru</code>, <code>en-GB</code>, <code>en-US</code>
                или вообще какой-нибудь <code>nan-Hant-TW</code>. Подробно о строении таких меток можно прочесть <a
                        href=https://www.w3.org/International/articles/language-tags/index.en>здесь</a>. В нашем случае
                задача немного упрощается, т.к. нам нужен только первый элемент (сам язык), независимо от региона (будем
                считать, к примеру, что «английский» английский и американский английский для нас одинаковы). Напишем
                наипростейшую определялку языка, которая будет возвращать <code>ru</code> для русского языка и
                <code>en</code> для всех остальных. В реальной жизни, конечно, стоит сделать поддержку большего числа
                языков.</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:#00f>def</span> get_language(lang_code):
    <span style=color:green># Иногда language_code может быть None</span>
    <span style=color:#00f>if</span> <span style=color:#00f>not</span> lang_code:
        <span style=color:#00f>return</span> <span style=color:#a31515>&#34;en&#34;</span>
    <span style=color:#00f>if</span> <span style=color:#a31515>&#34;-&#34;</span> <span style=color:#00f>in</span> lang_code:
        lang_code = lang_code.split(<span style=color:#a31515>&#34;-&#34;</span>)[0]
    <span style=color:#00f>if</span> lang_code == <span style=color:#a31515>&#34;ru&#34;</span>:
        <span style=color:#00f>return</span> <span style=color:#a31515>&#34;ru&#34;</span>
    <span style=color:#00f>else</span>:
        <span style=color:#00f>return</span> <span style=color:#a31515>&#34;en&#34;</span>
</code></pre>
            </div>
            <p>И подготовим небольшой JSON со строками:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-json data-lang=json><span>strings</span> <span>=</span> {
    &#34;ru&#34;: {
        &#34;ro_msg&#34;: <span style=color:#a31515>&#34;Вам запрещено отправлять сюда сообщения в течение 10 минут.&#34;</span>
    },
    &#34;en&#34;: {
        &#34;ro_msg&#34;: <span style=color:#a31515>&#34;You&#39;re not allowed to send messages here for 10 minutes.&#34;</span>
    }
</code></pre>
            </div>
            <p>Теперь напишем обработчик, который будет реагировать на набор фраз, выдавать режим Read-Only пользователю
                на 10 минут и уведомлять его на родном языке. Не забудьте импортировать метод <code>time</code> из
                одноимённого модуля!</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python>restricted_messages = [<span style=color:#a31515>&#34;я веган&#34;</span>, <span
                    style=color:#a31515>&#34;i am vegan&#34;</span>]

<span style=color:green># Выдаём Read-only за определённые фразы</span>
@bot.message_handler(func=<span style=color:#00f>lambda</span> message: message.text <span style=color:#00f>and</span> message.text.lower() <span
                        style=color:#00f>in</span> restricted_messages <span style=color:#00f>and</span> message.chat.id == GROUP_ID)
<span style=color:#00f>def</span> set_ro(message):
    bot.restrict_chat_member(message.chat.id, message.from_user.id, until_date=time()+600)
    bot.send_message(message.chat.id, strings.get(get_language(message.from_user.language_code)).get(<span
                        style=color:#a31515>&#34;ro_msg&#34;</span>),
                     reply_to_message_id=message.message_id)
</code></pre>
            </div>
            <p>Запустим бота и попросим людей с разными language_code выступить в роли противников мяса:</p>
            <center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l10_3.png></center>
            <center><i>Бот-полиглот</i></center>
            <h2 id=заключение>Заключение</h2>
            <p>В этом уроке мы кратко ознакомились с новыми фишками третьей версии Telegram Bot API, научились удалять
                сообщения, если они соответствуют одному из заданных критериев и научились «мягко» ограничивать
                пользователей, не удаляя их из группы. Помимо <code>restrict_chat_member</code> существует метод <code>promote_chat_member</code>
                для наделения пользователя определёнными администраторскими правами, он остаётся для самостоятельного
                изучения.</p>
            <p>Исходный код бота этого урока, как обычно, расположен на <a
                    href=https://github.com/MasterGroosha/telegram-tutorial/blob/master/lesson_10/bot.py>Github</a>.</p>
            <p><a href=/telegram-tutorial/docs/lesson_09/ class=book-btn style=float:left>← Урок №9</a>
                <a href=/telegram-tutorial/docs/lesson_11/ class=book-btn style=float:right>Урок №11 →</a></p></p>
        </article>
        <footer class=book-footer>
            <div class="flex flex-wrap justify-between"></div>
        </footer>
        <label class="hidden book-menu-overlay" for=menu-control></label></div>
    <aside class=book-toc>
        <nav id=TableOfContents>
            <ul>
                <li>
                    <ul>
                        <li><a href=#удаляем-сообщения>Удаляем сообщения</a></li>
                        <li><a href=#read-only-и-прочие-мягкие-наказания>Read-Only и прочие «мягкие» наказания</a></li>
                        <li><a href=#заключение>Заключение</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </aside>
</main>
</body>
</html>