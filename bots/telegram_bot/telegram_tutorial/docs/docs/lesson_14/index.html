<!doctype html>
<html lang=ru>
<head>
    <meta charset=utf-8>
    <meta content="width=device-width,initial-scale=1" name=viewport>
    <meta content="Конечные автоматы в aiogram, разбиваем логику по файлам" name=description>
    <meta content="#FFFFFF" name=theme-color>
    <meta content="Пишем ботов для Telegram на языке Python" property="og:title">
    <meta content="article" property="og:type">
    <meta content="Урок 14: Конечные автоматы в aiogram, разбиваем логику по файлам" property="og:description">
    <meta content="https://mastergroosha.github.io/telegram-tutorial/docs/lesson_14/" property="og:url">
    <meta content="Пишем ботов для Telegram на языке Python" property="og:site_name">
    <meta content="https://mastergroosha.github.io/telegram-tutorial/bot_logo.png" property="og:image">
    <title>Урок 14: Конечные автоматы в aiogram, разбиваем логику по файлам | Пишем ботов для Telegram на языке
        Python</title>
    <link href=/telegram-tutorial/manifest.json rel=manifest>
    <link href=/telegram-tutorial/favicon.png rel=icon type=image/x-icon>
    <link href=/telegram-tutorial/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css
          integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA+eA0kDHPqIYF+1eU="
          rel=stylesheet>
</head>
<body><input class=hidden id=menu-control type=checkbox>
<main class="container flex">
    <aside class=book-menu>
        <nav><h2 class=book-brand><a href=/telegram-tutorial><span>Пишем ботов для Telegram на языке Python</span></a>
        </h2>
            <ul>
                <li class=book-section-flat><span>pyTelegramBotAPI</span>
                    <ul>
                        <li><a href=/telegram-tutorial/docs/pyTelegramBotAPI/lesson_00/>Урок 0. Подготовка рабочего
                            места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. «Угадай мелодию». Подготовка</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. «Угадай мелодию». Завершаем бота</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan
                            (неактуально)</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование
                            сообщений</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять
                            редактирование сообщений, кэшированный инлайн</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в
                            группах</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги.
                            Конечные автоматы</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном
                            сервере</a></li>
                    </ul>
                </li>
                <li class=book-section-flat><span>aiogram</span>
                    <ul>
                        <li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li>
                        <li><a href=/telegram-tutorial/docs/lesson_14/ class=active>Урок 14. Конечные автоматы в
                            aiogram, разбиваем логику по файлам</a></li>
                    </ul>
                </li>
            </ul>
            <ul>
                <li><a href=/telegram-tutorial/posts/></a></li>
            </ul>
        </nav>
        <script>(function () {
            var menu = document.querySelector("aside.book-menu nav");
            addEventListener("beforeunload", function (event) {
                localStorage.setItem("menu.scrollTop", menu.scrollTop);
            });
            menu.scrollTop = localStorage.getItem("menu.scrollTop");
        })();</script>
    </aside>
    <div class=book-page>
        <header class=book-header>
            <div class="flex align-center justify-between"><label for=menu-control><img
                    alt=Menu class=book-icon src=/telegram-tutorial/svg/menu.svg></label>
                <strong>Урок 14</strong>
                <label for=toc-control><img alt="Table of Contents" class=book-icon src=/telegram-tutorial/svg/toc.svg></label>
            </div>
            <input class=hidden id=toc-control type=checkbox>
            <aside class="hidden clearfix">
                <nav id=TableOfContents>
                    <ul>
                        <li>
                            <ul>
                                <li><a href=#введение>Введение</a></li>
                                <li><a href=#разбиваем-хэндлеры-по-файлам>Разбиваем хэндлеры по файлам</a></li>
                                <li><a href=#снова-конечные-автоматы>Снова конечные автоматы</a></li>
                                <li><a href=#бонус>Бонус</a></li>
                            </ul>
                        </li>
                    </ul>
                </nav>
            </aside>
        </header>
        <article class=markdown><h1>Конечные автоматы в aiogram, разбиваем логику по файлам</h1>
            <p>
            <h2 id=введение>Введение</h2>
            <p>Сегодня мы научимся раскидывать хэндлеры по разным файлам, чтобы не плодить огромные портянки кода, а
                также познакомимся с механизмом FSM (Finite State Machine, конечный автомат состояний), но уже в
                библиотеке aiogram.</p>
            <blockquote class="book-hint info">Если по какой-то причине вы всё ещё используете
                <strong>pyTelegramBotAPI</strong>, то информация о FSM для него доступна в <a
                        href=/telegram-tutorial/docs/lesson_11/>уроке 11</a>.<br>Все исходные коды к этому уроку
                актуальны для <strong>aiogram</strong> версии 2.x. В будущем, когда выйдет третья версия фреймворка,
                этот урок может быть неактуален.
            </blockquote>
            <p>По мере усложнения ваших ботов, количетсво хэндлеров будет расти, это факт. Чтобы не запутаться, логично
                разнести обработчики по разным файлам, основываясь на их предназначении. Особенно это актуально для
                создания диалогов при помощи конечных автоматов. В этом уроке мы будем придерживаться правила «один файл
                — один диалог». Но обо всём по порядку.</p>
            <h2 id=разбиваем-хэндлеры-по-файлам>Разбиваем хэндлеры по файлам</h2>
            <p>Перейдите в директорию, где будет ваш будущий бот и создайте три объекта: файлы <code>bot.py</code> и
                <code>misc.py</code>, а также каталог <code>handlers</code>. В последнем будут располагаться хэндлеры.
                Откройте каталог handlers и создайте внутри ещё три файла: <code>__init__.py</code> (два нижних
                подчёркивания, слово <strong>init</strong>, ещё два нижних подчёркивания, точка и два английских символа
                “пи” и “уай”), <code>general_commands.py</code> и <code>default_handler.py</code>.</p>
            <p>Почему такое странное название у файла со словом init? Дело в том, что Python вложенные каталоги может
                считать отдельными модулями, что мы и будем использовать, а название <strong>init</strong> — служебное
                обозначение, принятое в языке. Внутри файла мы просто сделаем импорт всех нужных файлов с хэндлерами, но
                держа в голове важное правило: как и раньше, порядок включения файлов крайне важен! Например, если вы
                импортируете файл <strong>A</strong> с хэндлером на стикеры, а затем файл <strong>Б</strong> с точно
                таким же хэндлером, выполнится тот, что в файле <strong>А</strong>.</p>
            <p>Итак, содержимое файла <code>__init__.py</code>:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:#00f>from</span> . <span style=color:#00f>import</span> general_commands
<span style=color:#00f>from</span> . <span style=color:#00f>import</span> default_handler
</code></pre>
            </div>
            <p>И всё. Если в каталоге handlers появятся новые файлы, нужно будет просто отредактировать <code>__init__.py</code>,
                соблюдая нужный порядок. Теперь на минуту отвлечёмся от хэндлеров и подготовим самого бота. В <code>misc.py</code>
                просто объявим объект <code>Bot</code>:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:#00f>import</span> logging
<span style=color:#00f>from</span> aiogram <span style=color:#00f>import</span> Bot, Dispatcher

bot = Bot(token=<span style=color:#a31515>&#34;ВАШ_ТОКЕН&#34;</span>)
dp = Dispatcher(bot)
logging.basicConfig(level=logging.INFO)
</code></pre>
            </div>
            <p>В файле <code>bot.py</code> (он будет точкой входа) подключим созданный выше <code>misc.py</code>,
                каталог <code>handlers</code> и пропишем код для запуска поллинга:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:#00f>from</span> aiogram <span
                    style=color:#00f>import</span> executor
<span style=color:#00f>from</span> misc <span style=color:#00f>import</span> dp
<span style=color:#00f>import</span> handlers

<span style=color:#00f>if</span> __name__ == <span style=color:#a31515>&#34;__main__&#34;</span>:
    executor.start_polling(dp, skip_updates=True)
</code></pre>
            </div>
            <p>Вернёмся к хэндлерам и создадим парочку в разных файлах.
                Содержимое <code>general_commands.py</code>:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:#00f>from</span> aiogram <span
                    style=color:#00f>import</span> types
<span style=color:#00f>from</span> misc <span style=color:#00f>import</span> dp

@dp.message_handler(commands=[<span style=color:#a31515>&#39;start&#39;</span>])
async <span style=color:#00f>def</span> cmd_start(message: types.Message):
    await message.answer(<span style=color:#a31515>&#34;Обработчик команды /start&#34;</span>)
</code></pre>
            </div>
            <p>Содержимое <code>default_handler.py</code>:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:#00f>from</span> aiogram <span
                    style=color:#00f>import</span> types
<span style=color:#00f>from</span> lesson_14.misc <span style=color:#00f>import</span> dp


@dp.message_handler(content_types=types.ContentTypes.ANY)
async <span style=color:#00f>def</span> all_other_messages(message: types.Message):
    await message.answer(<span style=color:#a31515>&#34;Любое другое сообщение&#34;</span>)
</code></pre>
            </div>
            <p>Результат:</p>
            <center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l14_1.png></center>
            <center><i>Хэндлеры из разных файлов</i></center>
            <h2 id=снова-конечные-автоматы>Снова конечные автоматы</h2>
            <p>Судя по вашим, дорогие читатели, отзывам и вопросам, <a href=/telegram-tutorial/docs/lesson_11/>11-й
                урок</a> этого учебника оказался самым популярным и востребованным. Действительно, довольно часто
                возникает потребность сделать многоуровневую логику, постепенно собирая всю информацию для последующей
                обработки.</p>
            <p>В <strong>aiogram</strong> уже встроен механизм конечных автоматов с поддержкой различных хранилищ. Чтобы
                не усложнять материал, мы воспользуемся самым простым и ненадёжным типом: <strong>MemoryStorage</strong>.
                Как понятно из названия, он хранит «состояния» в оперативной памяти, из-за чего при любом завершении
                работы бота, успешном или неуспешном, вся информация бесследно исчезает. Все поддерживаемые типы
                хранилищ можно посмотреть <a
                        href=https://github.com/aiogram/aiogram/tree/master/aiogram/contrib/fsm_storage>на GitHub</a>.
            </p>
            <p>Поставим перед собой следующую задачу: написать бота, который будет предлагать пользователю выбрать в
                кафе еду или напитки, а затем уточнять их выбор. На первом шаге выбирается пункт меню по названию, затем
                размер порции, а в конце выводится выбранный продукт. Если пользователь выполняет команду
                <code>/cancel</code> или пишет «отмена» (в любом регистре), прекращаем обработку.</p>
            <p>Создадим в каталоге handlers два файла: <code>food.py</code> и <code>drinks.py</code>. Их содержимое
                будет очень похоже, поэтому в самом уроке мы рассмотрим только <code>food.py</code>. Для начала,
                импортируем все нужные объекты:</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:#00f>from</span> aiogram <span
                    style=color:#00f>import</span> types
<span style=color:#00f>from</span> aiogram.dispatcher <span style=color:#00f>import</span> FSMContext
<span style=color:#00f>from</span> aiogram.dispatcher.filters.state <span style=color:#00f>import</span> State, StatesGroup
<span style=color:#00f>from</span> misc <span style=color:#00f>import</span> dp
</code></pre>
            </div>
            <p>Список блюд и возможные размеры порций тоже объявим прямо в коде, хотя обычно такие вещи подгружаются из
                других источников (например, из базы данных):</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python>available_food_names = [<span style=color:#a31515>&#34;суши&#34;</span>, <span
                    style=color:#a31515>&#34;спагетти&#34;</span>, <span style=color:#a31515>&#34;хачапури&#34;</span>]
available_food_sizes = [<span style=color:#a31515>&#34;маленькую&#34;</span>, <span style=color:#a31515>&#34;среднюю&#34;</span>, <span
                        style=color:#a31515>&#34;большую&#34;</span>]
</code></pre>
            </div>
            <p>Создадим новый класс <strong>OrderFood</strong>, который, в свою очередь, наследуется от класса <strong>StatesGroup</strong>.
                В aiogram «состояния» можно объединять в группы, это удобно и несколько упрощает код. Пропишем
                «состояния» в том порядке, в котором они будут использоваться пользователем (т.е. шаг1 -> шаг2 -> шаг3 и
                т.д.):</p>
            <div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code
                    class=language-python data-lang=python><span style=color:#00f>class</span> <span
                    style=color:#2b91af>OrderFood</span>(StatesGroup):
    waiting_for_food_name = State()
    waiting_for_food_size = State()
</code></pre>
            </div>
            <p>Начало диалога про блюда всегда будет начинаться с команды <code>/food</code>. Если бот её получил, то
                надо забыть всё, что было раньше, и заняться обработкой этой ветки диалога. Внимательно посмотрите на
                следующий кусок кода:</p>
            <script src="https://gist.github.com/MasterGroosha/17775abb5b1e417d39a4dd58f2ed6c43.js?file=food_step_1.py"
                    type=application/javascript></script>
            <p>Обратите внимание на подхэндлерное выражение. Помимо знакомого аргумента <strong>commands</strong>
                появился ещё один: <strong>state</strong>. При использовании конечных автоматов, очень важно указывать
                «состояние», которое должно быть у конкретного пользователя, чтобы хэндлер сработал. В данном случае
                выставлено значение &ldquo;*&rdquo;, что означает «при любом состоянии». Т.е. независимо от текущего
                шага в каком-либо диалоге, отправка команды <code>/food</code> всегда попадёт в этот хэндлер.<br>В
                последней строке функции мы назначаем текущему пользователю состояние «ожидаем ввод названия блюда».
                Фреймворк aiogram сам поймёт, о каком пользователе речь, основываясь на сочетании <code>user_id</code> и
                <code>chat_id</code>, нам, как использующим фреймворк, об этом думать необязательно.</p>
            <p>Следующий хэндлер должен срабатывать только при активном состоянии &ldquo;OrderFood.waiting_for_food_name&rdquo;
                и если сообщение является обычным текстом, а не стикером или чем-либо ещё. На предыдущем шаге мы
                показали пользователю клавиатуру, поэтому дополнительно проверяем полученный текст в списке доступных
                блюд.</p>
            <script src="https://gist.github.com/MasterGroosha/17775abb5b1e417d39a4dd58f2ed6c43.js?file=food_step_2.py"
                    type=application/javascript></script>
            <p>Опять что-то новое! На этот раз, помимо аргумента message, в подхэндлерную функцию передаём второй
                аргумент <code>state</code>, имеющий тип <strong>FSMContext</strong>. Дело в том, что aiogram позволяет
                вместе с «состоянием» пользователя хранить дополнительную информацию, например, промежуточные
                результаты. Всё это складывается в отдельный словарь (dict). В нашем случае после выполнения хэндлера в
                «индивидуальном словаре» конкретного пользователя под ключом <code>chosen_food</code> будет храниться
                текст сообщения, приведённый к строчным буквам. Если пользователь ввёл что-то, отличное от показанного
                меню, хэндлер завершится раньше времени и «состояние» никак не изменится, что даст возможность
                пользователю попробовать ещё раз. Если же введённый текст окажется корректным, то бот отправлет новую
                клавиатуру и переключает «состояние» на следующее (вызов функции <code>next()</code>). Именно для этого
                нужно соблюдать порядок описания «состояний» в группе. Разумеется, можно было бы указать новое состояние
                вручную.</p>
            <p>Последний хэндлер станет обобщающим. Прежде всего, проверим, совпадает ли введённый пользователем текст с
                какой-либо из кнопок клавиатуры, предложенной на предыдущем шаге. Если всё верно, достаём
                «индивидуальный словарь» пользователя извлекаем оттуда название блюда и формируем сообщение, содержащее
                все выбранные ранее элементы. Напоследок очищаем «состояние» пользователя, вызвав метод
                <code>finish()</code>:</p>
            <script src="https://gist.github.com/MasterGroosha/17775abb5b1e417d39a4dd58f2ed6c43.js?file=food_step_3.py"
                    type=application/javascript></script>
            <p>Проверяем, как всё вместе работает:</p>
            <center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l14_2.png></center>
            <center><i>Пошаговый ввод данных</i></center>
            <p>Готово! Как видите, работа с конечными автоматами в aiogram проще, удобнее и приятнее, чем в
                pyTelegramBotAPI. Исходные тексты к уроку со всеми хэндлерами можно найти <a
                        href=https://github.com/MasterGroosha/telegram-tutorial/tree/master/lesson_14>на Github</a>.</p>
            <h2 id=бонус>Бонус</h2>
            <p>Начиная с <a href=https://core.telegram.org/bots/api-changelog#march-30-2020>Bot API v4.7</a> боты могут
                самостоятельно редактировать список своих команд, отображаемых в интерфейсе приложений при вводе символа
                &ldquo;/&rdquo;. Напишем хэндлер, который устанавливает для бота команды <code>/drinks</code> и <code>/food</code>:
            </p>
            <script src="https://gist.github.com/MasterGroosha/17775abb5b1e417d39a4dd58f2ed6c43.js?file=cmd_set_commands.py"
                    type=application/javascript></script>
            <p>Не забудьте перезапустить приложение Telegram, чтобы увидеть изменения. Кстати, если передать пустой
                список, то можно очистить список команд, чего так долго не хватало при общении с <a
                        href=https://t.me/botfather>@BotFather</a>.</p><a
                    href=/telegram-tutorial/docs/lesson_13/ class=book-btn style=float:left>← Урок №13</a></p></article>
        <footer class=book-footer>
            <div class="flex flex-wrap justify-between"></div>
        </footer>
        <label class="hidden book-menu-overlay" for=menu-control></label></div>
    <aside class=book-toc>
        <nav id=TableOfContents>
            <ul>
                <li>
                    <ul>
                        <li><a href=#введение>Введение</a></li>
                        <li><a href=#разбиваем-хэндлеры-по-файлам>Разбиваем хэндлеры по файлам</a></li>
                        <li><a href=#снова-конечные-автоматы>Снова конечные автоматы</a></li>
                        <li><a href=#бонус>Бонус</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </aside>
</main>
</body>
</html>